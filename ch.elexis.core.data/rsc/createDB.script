#/*******************************************************************************
# * Copyright (c) 2005-2018, G. Weirich and Elexis
# * All rights reserved. This program and the accompanying materials
# * are made available under the terms of the Eclipse Public License v1.0
# * which accompanies this distribution, and is available at
# * http://www.eclipse.org/legal/epl-v10.html
# *
# * Contributors:
# *    G. Weirich - initial implementation
# *    
# *******************************************************************************

# Universelles create-Script für Elexis.
# Wird von JdbcLink automatisch für mySQL, hsqldb und PostgreSQL angepasst
# Bei mySQL und PostgreSQL: Database Elexis muss schon existieren, darf aber
# noch keine Tabellen enthalten.
# ---------------------------------------------
# This script can create the elexis database on mysql, hsql and postresql servers
# Tha database should exist already, but should not contain any tables.
#
# WARNING: The database layout is internal to elexis and must not be assumed stable.
# Fields can be omitted or changed between versions.
# Access to persistent data has to be done via the API (ch.elexis.data.PersistentObject)


# Table for all kinds of contact information (Patients, Relations, Labs)
CREATE TABLE KONTAKT(
	ID				VARCHAR(36) primary key,	# UUIDv4 RFC 4122 /OR/ legacy Elexis StringTool.unique()
	lastupdate      BIGINT,                     # timestamp of last update
	deleted			CHAR(1) default '0',		# indicates that this object is marked deleted
	istOrganisation	CHAR(1) default '0',		# this object is an organization 
	istPerson		CHAR(1) default '0',		# this object is a person
	istPatient		CHAR(1)	default '0',		# is a patient
	istAnwender		CHAR(1) default '0',		# is an elexis user
	istMandant	    CHAR(1) default '0',		# is an elexis mandator
	istLabor		CHAR(1)	default '0',		# is a lab
	Land			CHAR(3),					# country as ISO code
	Geburtsdatum	CHAR(8),					# bithdate as yyyymmdd (ISO 8601 compliant)
	Geschlecht		CHAR(1),					# sex m or w
	TITEL			VARCHAR(255),				# title
	TitelSuffix		VARCHAR(255),				# title suffix
	Bezeichnung1	VARCHAR(255),				# name1
	Bezeichnung2	VARCHAR(255),				# name2
	Bezeichnung3	VARCHAR(255),				# name3
	Strasse			VARCHAR(255),				# street
	plz				VARCHAR(6),					# zip-code
	Ort				VARCHAR(255),				# place (possibly Llanfairpwllgwyngyllgogerychwyrndrobwllllantysiliogogogoch)
	Telefon1		VARCHAR(255),				# phone1
	Telefon2		VARCHAR(255),				# phone2
	fax				VARCHAR(255),				# you'll guess it
	NatelNr			VARCHAR(255),				# mobile
	EMail			VARCHAR(255),				# guess 
	Website			VARCHAR(255),
	gruppe			VARCHAR(10),				# mandator group
	patientnr		VARCHAR(40),				# external identifier
	anschrift		TEXT,						# postal (address sticker)
	bemerkung		TEXT,						# remarks
	diagnosen		BLOB,						# diagnoses	
	persanamnese	BLOB,						# anamnesis
	sysanamnese		BLOB,						# deprecated, do not use
	famanamnese	    BLOB,						# deprecated, do not use
	risiken			TEXT,						# risk factors
	allergien		TEXT,						# allergies
	extinfo			BLOB						# other informations (Hashtable)
);

CREATE INDEX k0 ON KONTAKT(Bezeichnung1);


# Verbindung von Kontakten zu Adressbezügen mit einem
# BezugsTEXT
CREATE TABLE KONTAKT_ADRESS_JOINT(
	ID			VARCHAR(36) primary key,
	lastupdate  BIGINT,
	deleted		CHAR(1) default '0',
	myid		VARCHAR(36),					# ID of a KONTAKT 
	otherid		VARCHAR(36),					# ID of a KONTAKT that ist related to myID
	bezug		VARCHAR(255),					# Description of the relationship
	myRType		CHAR(4),						# My formal relationship type
	otherRType	CHAR(4)							# Other formal relationship type
);

CREATE INDEX aij1 on KONTAKT_ADRESS_JOINT (myId);

# Ein Fall ist eine benannte Serie von Behandlungen, welche demselben
# Patienten und demselben Garanten zugeordnet werden. (Aber nicht
# notwendigerweise demselben Mandanten)
CREATE TABLE FAELLE(
	id				VARCHAR(36) primary key,		# UUID
	lastupdate      BIGINT,                         # timestamp of last write operation
	deleted			CHAR(1) default '0',			# indicates that this object is marked deleted
	patientid		VARCHAR(36),					# foreign key from 'KONTAKT' -> patient
	garantid		VARCHAR(36),					# foreign key from 'KONTAKT' -> bill receiver 
	kostentrid		VARCHAR(36),					# foreign key from 'KONTAKT' -> insurance
	versnummer		VARCHAR(25),					# deprecated, do not use
	fallnummer		VARCHAR(25),					# deprecated, do not use
	betriebsnummer	VARCHAR(25),					# deprecated, do not use
	diagnosen		VARCHAR(255),					# diagnoses related to this case
	datumvon		CHAR(8),						# date of beginning
	datumbis		CHAR(8),						# end date
	bezeichnung		VARCHAR(80),					# title of the case
	grund			VARCHAR(255),					# reason for treatment
	gesetz			VARCHAR(20),					# deprecated, do not use
	Status			VARCHAR(80),					# deprecated, do not use
	ExtInfo			BLOB							# additional informations (hashtable)
);

CREATE INDEX i3 on FAELLE (PatientID);

# Eine Behandlung ist ein einzelner Mandant/Patient - Kontakt
CREATE TABLE BEHANDLUNGEN(
	id				VARCHAR(36) primary key,		# UUID
	lastupdate      BIGINT,                         # timestamp
	deleted			CHAR(1) default '0',			# indicates that this object is marked deleted
	fallid			VARCHAR(36),					# foreign key from FAELLE -> case we belong to
	mandantid		VARCHAR(36),					# foreign key from KONTAKT -> mandator
	rechnungsid		VARCHAR(36),					# foreign key from RECHNUGNEN -> bill
	datum			CHAR(8),						# date of treatment as ISO 8601 (YYYYMMDD)
	zeit			CHAR(8),						# time of treatment as HH:MM:SS
	diagnosen		VARCHAR(25),					# diagnoses
	leistungen		VARCHAR(25),					# deprecated, do not use.
	eintrag			BLOB							# treatment text (as VersionedResource)
);

CREATE INDEX i4 on BEHANDLUNGEN (FallID);

# 
CREATE TABLE ARTIKEL(
	id				VARCHAR(36) primary key,		# UUID
	lastupdate      BIGINT,                         # timestamp
	deleted			CHAR(1) default '0',			# indicates that this object is marked deleted
	EAN				VARCHAR(15),                    # the european article number
	subid			VARCHAR(20),                    # an ID depending of the type (e.g. Pharmacode)
	lieferantid		VARCHAR(36),                    # foreign key from KONTAKT -> dealer
	Klasse			VARCHAR(80),					# class of the objects representing this article
	Name			VARCHAR(254),					# official name
	Name_intern		VARCHAR(254),					# internal name
	maxbestand		CHAR(4),						# max number to hold on stock
	minbestand		CHAR(4),						# min number on stock before ordering
	istbestand		CHAR(4),						# actual number on stock
	ek_preis		CHAR(8),						# cost (buy) in cents/rp
	vk_preis		CHAR(8),						# price (sell) in cents/rp
	typ				VARCHAR(15),					# type of the article
	codeclass		VARCHAR(10),					# used differently
	extid			VARCHAR(36),					# used differently
	ValidFrom		CHAR(8),			
	ValidTo			CHAR(8),
	ATC_code		VARCHAR(255),
	extinfo			BLOB							# additional informations (hashtable)
);

CREATE INDEX i5 on ARTIKEL (Name);
CREATE INDEX art1 on ARTIKEL (SubID);
CREATE INDEX art2 on ARTIKEL (Typ);
CREATE INDEX art3 on ARTIKEL (Codeclass);


# Relation of an article to a patient
CREATE TABLE PATIENT_ARTIKEL_JOINT(
	ID				VARCHAR(36) primary key,
	lastupdate      BIGINT,
	deleted			CHAR(1) default '0',
	patientid		VARCHAR(36),					# foreign key from KONTAKT
	artikelid		VARCHAR(36),					# foreign key from ARTIKEL  !!!! DEPRECATED DO NOT USE !!!
	Artikel			VARCHAR(255),					# cheap copy of article. replaces ArtikelID
	RezeptID		VARCHAR(36),					# prescription where this article was last given
	DateFrom		CHAR(24),						# first date
	DateUntil		CHAR(24),						# date the medication was stopped
	Dosis			VARCHAR(255),					# number
	Anzahl			CHAR(3),
	Bemerkung		VARCHAR(255),
	prescType		CHAR(2),						# the type of medication (fixed, prn)
	sortOrder		CHAR(3),						# manual sort order
	prescDate		CHAR(8),						# date medication was prescribed
	prescriptor		VARCHAR(36),					# the contact that prescribed this 
	ExtInfo			BLOB
);

CREATE INDEX paj1 on PATIENT_ARTIKEL_JOINT(PATIENTID);
CREATE INDEX PAJ2 on PATIENT_ARTIKEL_JOINT(REZEPTID);

CREATE TABLE ARTIKEL_DETAILS(   
    ARTICLE_ID      VARCHAR(36),                    # foreign key from ARTIKEL                     
    notes           TEXT, 		                    # informations or usage of the article
    image           BLOB     	              	    # an image or other binary data
);

# Das Konto ist eine Liste sämtlicher Forderungen und Zahlungen
# Somit lässt sich für jeden Patienten über alle bisherigen
# Rechnungen eine übergreifende Bilanz erstellen und verrechnen.
CREATE TABLE KONTO(
	id				VARCHAR(36) primary key,
	lastupdate      BIGINT,
	deleted			CHAR(1) default '0',
	PatientID		VARCHAR(36),              # foreign key from KONTAKT 
	RechnungsID		VARCHAR(36),              # foreign key from RECHNUNG
	ZahlungsID		VARCHAR(36),              # foreign key from ZAHLUNG
	Betrag			VARCHAR(8),
	Datum			CHAR(8),
	Bemerkung		VARCHAR(255)
);

CREATE INDEX konto1 on KONTO (Datum);
CREATE INDEX konto2 on KONTO (PatientID);

# Eine Leistung ist eine einzelne Verrechnungsposition
CREATE TABLE LEISTUNGEN(
	id				VARCHAR(36) primary key,
	lastupdate      BIGINT,
	deleted			CHAR(1) default '0',
	BEHANDLUNG		VARCHAR(36),
	LEISTG_TXT		VARCHAR(255),
	LEISTG_CODE		VARCHAR(80),
	KLASSE			VARCHAR(80),
	ZAHL			CHAR(3),
	EK_KOSTEN		CHAR(8),
	VK_TP			CHAR(8),
	VK_SCALE		CHAR(8),
	VK_PREIS		CHAR(8),
	SCALE			CHAR(4) DEFAULT '100',
	SCALE2			CHAR(4) DEFAULT '100',
	userID			VARCHAR(36),				# foreign key on user
	DETAIL			BLOB
);

CREATE INDEX lst1 on LEISTUNGEN(BEHANDLUNG);
CREATE INDEX lst2 on LEISTUNGEN(KlASSE,LEISTG_CODE);

CREATE TABLE EK_PREISE(
	typ				VARCHAR(80),
	id				VARCHAR(36),
	lastupdate      BIGINT,
	DATUM_VON		CHAR(8),
	DATUM_BIS		CHAR(8),
	MULTIPLIKATOR	VARCHAR(8)
);

CREATE INDEX ekp1 ON EK_PREISE (TYP);
CREATE INDEX ekp2 ON EK_PREISE (DATUM_VON);


CREATE TABLE VK_PREISE(
	typ				VARCHAR(80),
	id				VARCHAR(36),
	lastupdate      BIGINT,
	DATUM_VON		CHAR(8),
	DATUM_BIS		CHAR(8),
	MULTIPLIKATOR	CHAR(8)
);

CREATE INDEX vkp1 on VK_PREISE (TYP);
CREATE INDEX vkp2 on VK_PREISE (DATUM_VON);


CREATE TABLE DIAGNOSEN(
	id				VARCHAR(36) primary key,
	lastupdate      BIGINT,
	deleted			CHAR(1) default '0',
	DG_TXT			VARCHAR(255),
	DG_CODE			VARCHAR(255),
	KLASSE			VARCHAR(80)
);

CREATE INDEX dg1 on DIAGNOSEN (KLASSE,DG_CODE);

CREATE TABLE BEHDL_DG_JOINT(
	id				VARCHAR(36),
	lastupdate      BIGINT,
	deleted			CHAR(1) default '0',
	BehandlungsID	VARCHAR(36),
	DiagnoseID		VARCHAR(36),
	PRIMARY KEY (BehandlungsID, DiagnoseID)
);

# Verschiedene Konfigurationsdaten
CREATE TABLE CONFIG(
    lastupdate      BIGINT,
	param			VARCHAR(80) primary key,
	wert			TEXT
);

# Briefe werden nicht in dieser Tabelle gespeichert.
# Hier befinden sich nur Verweise und Metainformationen zu
# den eigentlichen Briefen (welche in HEAP oder im Dateisystem sein können).
CREATE TABLE BRIEFE(
	ID				VARCHAR(36) primary key,
	lastupdate      BIGINT,
	deleted			CHAR(1) default '0',
	Betreff			VARCHAR(255),
	Datum			CHAR(24),
	modifiziert		CHAR(24),
	gedruckt		CHAR(8),
	geloescht		CHAR(2),
	note			TEXT,		  		   # Notizen
	absenderid		VARCHAR(36),           # foreign key from KONTAKT
	destid			VARCHAR(36),           # foreign key from KONTAKT
	behandlungsid	VARCHAR(36),           # foreign key from BEHANDLUNG
	patientid		VARCHAR(36),           # foreign key from KONTAKT
	Typ				VARCHAR(30),
	MimeType		VARCHAR(80),
	Path			TEXT
);

CREATE INDEX i8 on BRIEFE (BehandlungsID);

# Output log for letters, prescriptions etc.
CREATE TABLE OUTPUT_LOG(
	ID				VARCHAR(36) primary key,
	lastupdate		BIGINT,
	deleted			CHAR(1) default '0',
	ObjectID		VARCHAR(36),		# foreign key from object
	ObjectType		VARCHAR(80),		# Class of object
	Datum			CHAR(8),
	Outputter		VARCHAR(255),		# identification of the output device/program
	ExtInfo			BLOB				# outputter specific information
);

CREATE INDEX bal_i1 ON OUTPUT_LOG (ObjectID);

# Bills
CREATE TABLE RECHNUNGEN(
	id				VARCHAR(36) primary key,     # UUID
	lastupdate      BIGINT,
	deleted			CHAR(1) default '0',         # indicates that this object is marked deleted
	rnnummer		VARCHAR(8),                  # Number of the bill (unique within this database)
	fallid			VARCHAR(36),                 # foreign key from FAELLE (case this bill belongs to)
	mandantid		VARCHAR(36),                 # foreign key from KONTAKT (mandator this bill beongs to)
	rndatum			CHAR(8),                     # date of creating this bill
	rnstatus		VARCHAR(20),                 # state of this bill (e.g. open, payed)
	rndatumvon	    CHAR(8),                     # date of first treatment billed
	rndatumbis		CHAR(8),                     # date of last treatment billed
	betrag			CHAR(8),                     # amount in Rp / cents
	StatusDatum		CHAR(8),                     # date of last state change
	ExtInfo			BLOB                         # hastable for trace infos etc.
);

CREATE INDEX Rn1 on RECHNUNGEN (FallID);
CREATE INDEX Rn2 on RECHNUNGEN (MandantID);
CREATE INDEX Rn3 ON RECHNUNGEN (RnStatus);
CREATE INDEX Rn4 ON RECHNUNGEN (RnDatumVon);
CREATE INDEX Rn5 ON RECHNUNGEN (RnDatumBis);

# payments
CREATE TABLE ZAHLUNGEN(
	id				VARCHAR(36) primary key,     # UUID
	lastupdate      BIGINT,
	deleted			CHAR(1) default '0',         # indicates that this object is marked deleted
	rechnungsid		VARCHAR(36),                 # bill this payment belongs to (can be null)
	betrag			CHAR(8),                     # amount of this payment in Rp/cents
	datum			CHAR(8),                     # date of this payment
	bemerkung		VARCHAR(255)                 # remark
);

CREATE INDEX zahl1 on ZAHLUNGEN(RechnungsID);

CREATE TABLE REMINDERS(
	id				VARCHAR(36) primary key,
	lastupdate      BIGINT,
	deleted			CHAR(1) default '0',
	identid			VARCHAR(36),                 # foreign key from KONTAKT
	originid		VARCHAR(36),                 # foreign key from KONTAKT
	responsible  	VARCHAR(36),                 # foreign key from KONTAKT
	datedue			CHAR(8),
	status			CHAR(1),
	typ				CHAR(1),
	params			TEXT,
	message			TEXT,
	priority		CHAR(1),
	actionType		CHAR(2),
	subject			VARCHAR(255)
);

CREATE TABLE REMINDERS_RESPONSIBLE_LINK(
	ID				VARCHAR(36),
	lastupdate      BIGINT,
	deleted			CHAR(1) default '0',
	ReminderID		VARCHAR(36),                  # foreign key from REMINDERS
	ResponsibleID	VARCHAR(36),               # foreign key from KONTAKT
	PRIMARY KEY (ReminderID, ResponsibleID)
);

CREATE INDEX rrl1 on REMINDERS_RESPONSIBLE_LINK (ReminderID);
CREATE INDEX rrl2 on REMINDERS_RESPONSIBLE_LINK (ResponsibleID);

CREATE INDEX rem1 on REMINDERS (IdentID);
CREATE INDEX rem2 on REMINDERS (DateDue);
CREATE INDEX rem3 ON REMINDERS (Responsible);


# Die Trace-Table kann (wenn Trace eingeschaltet wurde) jeden Schreibzugriff
# auf die Datenbank protokollieren, und zwar mit Zeit, Datum, Arbeitsstation 
# und dort angemeldetem Benutzer. so können Fehlbedienungen besser erfasst und
# korrigiert werden.
CREATE TABLE TRACES(
	logtime			BIGINT,
	Workstation		VARCHAR(40),
	Username		VARCHAR(30),
	action			TEXT
);

CREATE INDEX trace1 on TRACES(logtime);
CREATE INDEX trace2 on TRACES(Username);

# Das Schwarze Brett der Praxis
CREATE TABLE BBS(
	id			VARCHAR(36) primary key,
	lastupdate  BIGINT,
	deleted		CHAR(1) default '0',
	reference	VARCHAR(36),
	topic		VARCHAR(80),
	date		CHAR(8),
	time		CHAR(4),
	authorID	VARCHAR(36),
	message		TEXT
);

CREATE INDEX bbs1 on BBS (reference);

# Ein Laboritem ist ein möglicher Laborbefund. Jedes
# Laboritem hat ein Labor, von dem es gemacht wird
# und den von diesem Labor stammenden Referenzbereich
# Typ des Werts ist entweder numerisch(0), TEXT (1) oder pos/neg (2)
# Ausserdem gehört jedes Laboritem zu einer Gruppe (unter der es im Laborblatt
# aufgelistet wird, und eine Priorität mit der es innerhalb dieser Gruppe
# gelistet ist.

CREATE TABLE LABORITEMS(
	id			VARCHAR(36) primary key,
	lastupdate  BIGINT,
	deleted		CHAR(1) default '0',
	kuerzel		VARCHAR(80),
	titel		VARCHAR(80),
	laborID		VARCHAR(36),                   # foreign key from KONTAKT
	RefMann		VARCHAR(255),
	RefFrauOrTx VARCHAR(255),
	Einheit		VARCHAR(20),
	typ			CHAR(1),
	Gruppe		VARCHAR(36),
	prio		CHAR(3),
	billingcode	VARCHAR(128),					# Code for automatic billing (from e.g EAL2009)
	export		VARCHAR(100),
	loinccode   VARCHAR(128),
	visible     VARCHAR(1),
	digits      VARCHAR(16),
	formula     VARCHAR(255)
);
	
CREATE INDEX labit1 on LABORITEMS(kuerzel);
CREATE INDEX labit2 on LABORITEMS(laborID);

# Laborwerte sind zuordnungen von Laboritems zu Datum und Patient
# mit dem entsprechenden Resultat.

CREATE TABLE LABORWERTE(
	id			VARCHAR(36) primary key,
	lastupdate  BIGINT,
	deleted		CHAR(1) default '0',
	patientid	VARCHAR(36),              # foreign key from KONTAKT
	datum		CHAR(8),
	zeit        CHAR(6),
	itemid		VARCHAR(36),                # foreign key from LABORIMTEMS
	Resultat	VARCHAR(255),
	Flags		VARCHAR(10),
	Origin		VARCHAR(36),
	unit        VARCHAR(255),
	analysetime VARCHAR(24),
	observationtime VARCHAR(24),
	transmissiontime VARCHAR(24),
	refmale     VARCHAR(255),
	reffemale   VARCHAR(255),
	OriginID    VARCHAR(36),
	Kommentar	TEXT,
	ExtInfo		BLOB
);

CREATE INDEX labor1 on LABORWERTE (PatientID);
CREATE INDEX labor2 on LABORWERTE (datum);
CREATE INDEX labor3 on LABORWERTE (ItemID);

CREATE TABLE LABGROUPS(
   ID VARCHAR(36) primary key,
   lastupdate   BIGINT,
   deleted		CHAR(1) default '0',
   name VARCHAR(80)
); 

CREATE TABLE LABGROUP_ITEM_JOINT(
     lastupdate      BIGINT,
     GroupID        VARCHAR(36),
     ItemID         VARCHAR(36),
     Comment        TEXT
); 

CREATE TABLE LABORDER (
	id VARCHAR(36) primary key,
	lastupdate BIGINT,
	deleted CHAR(1) default '0',
	userid VARCHAR(128),
	mandant VARCHAR(128),
	patient VARCHAR(128),
	item VARCHAR(128),
	result VARCHAR(128),
	orderid VARCHAR(128),
	groupname VARCHAR(255),
	time VARCHAR(24),
	observationtime VARCHAR(24),
	state CHAR(1)		
);

CREATE INDEX laborder1 ON LABORDER (time);
CREATE INDEX laborder2 ON LABORDER (mandant);
CREATE INDEX laborder3 ON LABORDER (patient);
CREATE INDEX laborder4 ON LABORDER (orderid);

CREATE TABLE REZEPTE(
	id			VARCHAR(36) primary key,
	lastupdate  BIGINT,
	deleted		CHAR(1) default '0',
	patientid	VARCHAR(36),                  # foreign key from KONTAKT
	mandantid	VARCHAR(36),                  # foreign key from KONTAKT
	BriefID		VARCHAR(36),                  # foreign key from BRIEFE
	datum		CHAR(8),
	RpTxt		TEXT,
	RpZusatz	VARCHAR(80)
);	

CREATE INDEX rp1 on REZEPTE(PatientID);

# Tabelle zum Speichern von benannten BLOB's verschiedener Herkunft
CREATE TABLE HEAP(
	ID			VARCHAR(80) primary key,
	lastupdate  BIGINT,
	deleted		CHAR(1) default '0',
	inhalt		BLOB,
	datum		CHAR(8)
);

CREATE TABLE AUF(
	id			VARCHAR(36) primary key,
	lastupdate  BIGINT,
	deleted		CHAR(1) default '0',
	patientid	VARCHAR(36),
	fallid		VARCHAR(36),
	briefid		VARCHAR(36),
	prozent		CHAR(3),
	DatumAUZ	CHAR(8),
	datumvon	CHAR(8),
	datumbis	CHAR(8),
	Grund		VARCHAR(50),
	AUFZusatz	VARCHAR(255)
);
	
CREATE INDEX AUF1 on AUF(PatientID);

CREATE TABLE EIGENLEISTUNGEN(
	ID			VARCHAR(36) primary key,
	lastupdate  BIGINT,
	deleted		CHAR(1) default '0',
	Code		VARCHAR(20),
	Bezeichnung VARCHAR(80),
	EK_PREIS	CHAR(6),
	VK_PREIS	CHAR(6),
	ZEIT		CHAR(4)
);

CREATE TABLE HEAP2(
	ID		    VARCHAR(80) primary key,
	deleted		CHAR(1) default '0',
	datum		CHAR(8),
	lastupdate  BIGINT,
	Contents	BLOB
);

CREATE TABLE LOGS(
	ID			VARCHAR(36) primary key,	# log entry's id
	lastupdate  BIGINT,
	deleted     char(1) default '0',
	OID			VARCHAR(255),				# foreign key on modified object
	datum		CHAR(8),					# date of modification
	typ			VARCHAR(80),				
	userID		VARCHAR(36),				# foreign key on modifying user
	station		VARCHAR(255),				# modifying workstation name
	ExtInfo		BLOB
);

CREATE TABLE USERCONFIG(
    lastupdate  BIGINT,
	UserID		VARCHAR(36),
	Param		VARCHAR(80),
	Value		TEXT
);
CREATE INDEX UCFG ON USERCONFIG(Param);
CREATE INDEX UCFG2 ON USERCONFIG(UserID);

CREATE TABLE XID(
	ID			VARCHAR(36) primary key,
	lastupdate  BIGINT,
	deleted		CHAR(1) default '0',
	type		VARCHAR(80),				# class of the object
	object		VARCHAR(36),				# ID of the object
	domain		VARCHAR(255),				# Domain of the XID used
	domain_id	VARCHAR(255),				# ID of the object within that domain
	quality		CHAR(1) default '0'			# Assignment tag of the XID
);
CREATE INDEX XIDIDX1 on XID(domain);
CREATE INDEX XIDIDX2 on XID(domain_id);
CREATE INDEX XIDIDX3 on XID(object);

CREATE TABLE ETIKETTEN(  
    ID          VARCHAR(36) primary key,
    lastupdate  BIGINT,
    Image       VARCHAR(36),
    deleted     CHAR(1) default '0',
    importance	VARCHAR(7),
    Name        VARCHAR(40),
    foreground  CHAR(6),
    background  CHAR(6),
    classes     VARCHAR(255)
);
CREATE INDEX ETIKETTE1 on ETIKETTEN(Name);

CREATE TABLE ETIKETTEN_OBJECT_LINK(
    lastupdate  BIGINT,
	obj			VARCHAR(36),
	etikette	VARCHAR(36)
);
CREATE INDEX ETIKETTE2 on ETIKETTEN_OBJECT_LINK(obj);
CREATE INDEX ETIKETTE3 on ETIKETTEN_OBJECT_LINK(etikette);

CREATE TABLE ETIKETTEN_OBJCLASS_LINK(
	objclass VARCHAR(80),
	sticker VARCHAR(36)
);
CREATE INDEX eol1 on ETIKETTEN_OBJCLASS_LINK(objclass);

CREATE TABLE DBIMAGE (
    ID             VARCHAR(36) primary key,
    lastupdate     BIGINT,
    deleted        CHAR(1) default '0',
    Datum          CHAR(8),
    Prefix		   VARCHAR(80),				# A Unique ID of the image creator/importer
    Title          VARCHAR(80),  			# A title unique within the prefix's namespace
    Bild           BLOB
);
CREATE INDEX DBIMAGE1 on DBIMAGE(Title);     

CREATE TABLE STOCK (
	ID VARCHAR(36) NOT NULL,
	LASTUPDATE BIGINT DEFAULT NULL,
	DELETED CHAR(1) DEFAULT '0',
	PRIORITY INTEGER DEFAULT 255,
	CODE CHAR(3), 
	DESCRIPTION VARCHAR(255), 
	LOCATION VARCHAR(255), 
	OWNER VARCHAR(36), 
	RESPONSIBLE VARCHAR(36),
	DRIVER_UUID VARCHAR(64), 
	DRIVER_CONFIG TEXT,
	PRIMARY KEY (ID)
);

INSERT INTO STOCK (ID, CODE, PRIORITY) VALUES ('STD', 'STD', '0');

CREATE TABLE STOCK_ENTRY (
	ID VARCHAR(36) NOT NULL,
	LASTUPDATE BIGINT DEFAULT NULL,
	DELETED CHAR(1) DEFAULT '0',
	STOCK VARCHAR(36) NOT NULL,
	ARTICLE_TYPE VARCHAR(255) NOT NULL,
	ARTICLE_ID VARCHAR(36) NOT NULL, 
	MIN INTEGER DEFAULT 0, 
	CURRENT INTEGER DEFAULT 0, 
	MAX INTEGER DEFAULT 0, 
	FRACTIONUNITS INTEGER DEFAULT 0,
	PROVIDER VARCHAR(36), 
	PRIMARY KEY (ID)
);

CREATE INDEX STOCK_ENTRY_STOCK0 ON STOCK_ENTRY(STOCK);
CREATE INDEX STOCK_ENTRY_TYPE0 ON STOCK_ENTRY(ARTICLE_TYPE);
CREATE INDEX STOCK_ENTRY_ID0 ON STOCK_ENTRY(ARTICLE_ID);

ALTER TABLE STOCK_ENTRY 
	ADD CONSTRAINT FK_STOCK_ENTRY_STOCK_ID FOREIGN KEY (STOCK) REFERENCES STOCK (ID);
	
CREATE TABLE IF NOT EXISTS BESTELLUNGEN (
	ID       	VARCHAR(80) NOT NULL,
 	LASTUPDATE 	BIGINT DEFAULT NULL,
  	DELETED 	CHAR(1) DEFAULT '0',
	DATUM  	    CHAR(8),
	CONTENTS 	BLOB,
	PRIMARY KEY (ID)
);

CREATE TABLE BESTELLUNG_ENTRY (
	ID VARCHAR(36) NOT NULL,
	LASTUPDATE BIGINT DEFAULT NULL,
	DELETED CHAR(1) DEFAULT '0',
	BESTELLUNG VARCHAR(80) NOT NULL, 
	STOCK VARCHAR(36), 
	ARTICLE_TYPE VARCHAR(255) NOT NULL,
	ARTICLE_ID VARCHAR(36) NOT NULL,
	COUNT INTEGER DEFAULT '0',
	PROVIDER VARCHAR(36),
	STATE INTEGER DEFAULT '0',
	PRIMARY KEY (ID)
);

ALTER TABLE BESTELLUNG_ENTRY 
	ADD CONSTRAINT FK_BESTELLUNG_ENTRY_BESTELLUNG_ID FOREIGN KEY (BESTELLUNG) REFERENCES BESTELLUNGEN (ID);

CREATE TABLE ZUSATZADRESSE (
	ID       	VARCHAR(41) NOT NULL,
 	LASTUPDATE 	BIGINT DEFAULT NULL,
  	DELETED 	CHAR(1) DEFAULT '0',
	Kontakt_ID		VARCHAR(36)  NOT NULL,
	STRASSE1		VARCHAR(255),
	STRASSE2		VARCHAR(255),
	PLZ				VARCHAR(6),		
	ORT				VARCHAR(255),
	LAND			CHAR(3),			
	TYP 			CHAR(4) DEFAULT '0',
	Anschrift		TEXT,
	PRIMARY KEY (ID)
	
);

CREATE TABLE ROLE (
  ID VARCHAR(36) NOT NULL,
  LASTUPDATE BIGINT DEFAULT NULL,
  DELETED CHAR(1) DEFAULT '0',
  EXTINFO BLOB,
  ISSYSTEMROLE CHAR(1) DEFAULT '0',
  PRIMARY KEY (ID)
);
 
INSERT INTO ROLE (ID, ISSYSTEMROLE) VALUES ('user', '1');
INSERT INTO ROLE (ID, ISSYSTEMROLE) VALUES ('user_external', '1');
INSERT INTO ROLE (ID, ISSYSTEMROLE) VALUES ('executive_doctor', '1');
INSERT INTO ROLE (ID, ISSYSTEMROLE) VALUES ('doctor', '1');
INSERT INTO ROLE (ID, ISSYSTEMROLE) VALUES ('assistant', '1');
INSERT INTO ROLE (ID, ISSYSTEMROLE) VALUES ('patient', '1');

CREATE TABLE USER_ROLE_JOINT (
  ID VARCHAR(36) NOT NULL,
  LASTUPDATE BIGINT DEFAULT NULL,
  DELETED CHAR(1) DEFAULT NULL,
  USER_ID VARCHAR(36) NOT NULL,
  PRIMARY KEY (ID, USER_ID)
);

# We must not name the table RIGHT, as this is an SQL keyword
CREATE TABLE RIGHT_ (
  ID VARCHAR(36) NOT NULL, 				# from ACE#getUniqueHashFromACE()
  LASTUPDATE BIGINT DEFAULT NULL,
  DELETED CHAR(1) DEFAULT '0',
  LOG_EXECUTION CHAR(1),
  NAME VARCHAR(256),
  PARENTID VARCHAR(36),
  I18N_NAME VARCHAR(256),
  PRIMARY KEY (ID)
);

INSERT INTO RIGHT_ (ID, NAME, PARENTID) VALUES ('root', 'root', '');

# Join the roles with the rights
CREATE TABLE ROLE_RIGHT_JOINT (
  ID VARCHAR(36) NOT NULL,
  LASTUPDATE BIGINT DEFAULT NULL,
  DELETED CHAR(1) DEFAULT NULL,
  ROLE_ID VARCHAR(36) NOT NULL,
  PRIMARY KEY (ID, ROLE_ID)
);

# We prepare a view to join the rights of a user for easy querying
CREATE OR REPLACE VIEW RIGHTS_PER_ROLE AS SELECT 
	r.ID AS ROLE_ID, ri.ID AS RIGHT_ID
FROM 
	ROLE r
	LEFT JOIN ROLE_RIGHT_JOINT rrj
		ON r.ID = rrj.ROLE_ID
	LEFT JOIN RIGHT_ ri
		ON rrj.ID = ri.ID
ORDER BY r.ID;

# We prepare a view to join the rights of a user for easy querying
CREATE OR REPLACE VIEW RIGHTS_PER_USER AS SELECT 
	u.ID AS USER_ID, ri.ID AS RIGHT_ID, ri.NAME AS RIGHT_NAME
FROM 
	USER_ u
	LEFT JOIN USER_ROLE_JOINT urj 
		ON u.ID = urj.USER_ID
	LEFT JOIN ROLE r
		ON urj.ID = r.ID
	LEFT JOIN ROLE_RIGHT_JOINT rrj
		ON r.ID = rrj.ROLE_ID
	LEFT JOIN RIGHT_ ri
		ON rrj.ID = ri.ID
ORDER BY u.ID;

CREATE TABLE USER_ (
  ID VARCHAR(36) NOT NULL,				# the username is the id
  DELETED CHAR(1) DEFAULT '0',
  KONTAKT_ID VARCHAR(36),				# foreign key to contact table
  LASTUPDATE BIGINT,
  HASHED_PASSWORD VARCHAR(64),			# Currently SHA-256
  SALT VARCHAR(64),						# The SALT used for SHA256_PASSWORD hash
  IS_ACTIVE CHAR(1) DEFAULT '1', 		# Is this account currently active? If not, any log-in is to be prohibited.
  IS_ADMINISTRATOR CHAR(1) DEFAULT '0',	# User is an administrator
  KEYSTORE TEXT,						# For key based authentication or signature purposes
  EXTINFO BLOB,
  PRIMARY KEY (ID)
);

# default password is 'administrator'
# http://java.dzone.com/articles/secure-password-storage-lots
INSERT INTO USER_ (ID, IS_ADMINISTRATOR, SALT, HASHED_PASSWORD) 
	VALUES ('Administrator', '1', '1254bb9a05856b9e', 'b94a0b6fc7be97e0a1585ac85e814d3852668968');
	
INSERT INTO CONFIG (param,wert) VALUES ('dbversion','3.5.0');
INSERT INTO CONFIG (param,wert) VALUES ('ElexisVersion','3.4.0');
